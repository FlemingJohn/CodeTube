/**
 * @file Firebase Security Rules for CodeTube Firestore database.
 *
 * Core Philosophy:
 * This ruleset enforces a hybrid access model. User-specific data (profiles, private courses, and chapters) is strictly controlled by the owning user. Publicly accessible courses are available for read access if explicitly published by the owner.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only to the user themselves.
 * - /users/{userId}/courses/{courseId}: Stores private course copies, accessible only to the course owner.
 * - /users/{userId}/courses/{courseId}/chapters/{chapterId}: Stores chapters for private courses, accessible only to the course owner.
 * - /courses/{courseId}: Stores public course copies, accessible for read by anyone if the 'published' flag is true.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Users can only create, read, update, and delete courses and chapters under their own user ID.
 * - Public courses are readable by anyone but can only be created, updated, or deleted by the course owner.
 * - Data shape is not strictly validated in this prototyping phase.  Only relational integrity (ownership) is enforced.
 *
 * Denormalization for Authorization:
 * - The `courses` collection contains a denormalized copy of course data for public access. The `published` field is used to control read access.
 * - Each course and chapter document has a `userId` and `courseId` to associate with the user.
 *
 * Structural Segregation:
 * - Private courses and chapters are stored under the `/users/{userId}` tree, while public courses are stored in the top-level `/courses` collection. This separation ensures that private data is never exposed publicly.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data.
     * @path /users/{userId}
     * @allow (get, create, update, delete, list): If the requesting user's ID matches the `userId` in the path (i.e., the user is accessing their own profile).
     * @deny (get, create, update, delete, list): If the requesting user's ID does not match the `userId` in the path (i.e., the user is trying to access another user's profile).
     * @principle Enforces user-ownership for profile data.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // Prevent listing of all users

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to private course data for a specific user.
     * @path /users/{userId}/courses/{courseId}
     * @allow (get, create, update, delete, list): If the requesting user's ID matches the `userId` in the path (i.e., the user is the owner of the course).
     * @deny (get, create, update, delete, list): If the requesting user's ID does not match the `userId` in the path (i.e., the user is not the owner of the course).
     * @principle Enforces user-ownership for course data.
     */
    match /users/{userId}/courses/{courseId} {
        function isOwner(userId) {
            return request.auth.uid == userId;
        }

        function isSignedIn() {
            return request.auth != null;
        }

        allow get: if isSignedIn() && isOwner(userId);
        allow list: if false;

        allow create: if isSignedIn() && isOwner(userId);
        allow update: if isSignedIn() && isOwner(userId);
        allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to chapters within a user's private course.
     * @path /users/{userId}/courses/{courseId}/chapters/{chapterId}
     * @allow (get, create, update, delete, list): If the requesting user's ID matches the `userId` in the path (i.e., the user is the owner of the course and its chapters).
     * @deny (get, create, update, delete, list): If the requesting user's ID does not match the `userId` in the path (i.e., the user is not the owner of the course or its chapters).
     * @principle Enforces user-ownership for chapter data.
     */
    match /users/{userId}/courses/{courseId}/chapters/{chapterId} {
        function isOwner(userId) {
            return request.auth.uid == userId;
        }

        function isSignedIn() {
            return request.auth != null;
        }

        allow get: if isSignedIn() && isOwner(userId);
        allow list: if false;

        allow create: if isSignedIn() && isOwner(userId);
        allow update: if isSignedIn() && isOwner(userId);
        allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to public course data.  Anyone can read a course if it is published.  Only the owner can modify it.
     * @path /courses/{courseId}
     * @allow (get, list): If the `published` field in the course document is true.
     * @allow (create, update, delete): If the requesting user's ID matches the `userId` in the course document (i.e., the user is the owner of the course).
     * @deny (create, update, delete): If the requesting user's ID does not match the `userId` in the course document (i.e., the user is not the owner of the course).
     * @principle Enforces public read access for published courses and user-ownership for modifying course data.
     */
    match /courses/{courseId} {
      function isOwner() {
          return resource.data.userId == request.auth.uid;
      }

      function isSignedIn() {
          return request.auth != null;
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isOwner();
      allow delete: if isSignedIn() && isOwner();
    }
  }
}